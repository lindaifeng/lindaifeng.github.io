import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,f as l}from"./app-yhW6njzi.js";const n={},e=l(`<h1 id="_5-5-jvm垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#_5-5-jvm垃圾回收机制"><span>5.5 JVM垃圾回收机制</span></a></h1><h2 id="核心理论" tabindex="-1"><a class="header-anchor" href="#核心理论"><span>核心理论</span></a></h2><h3 id="_1-1-垃圾回收基本概念" tabindex="-1"><a class="header-anchor" href="#_1-1-垃圾回收基本概念"><span>1.1 垃圾回收基本概念</span></a></h3><p>垃圾回收（Garbage Collection, GC）是JVM自动管理内存的机制，主要负责：</p><ul><li>识别内存中不再使用的对象（垃圾）</li><li>回收这些对象占用的内存空间</li><li>整理内存碎片（可选）</li></ul><p>垃圾回收的目标是实现内存自动管理，减少内存泄漏和内存溢出问题，提高开发效率。</p><h3 id="_1-2-对象存活判定算法" tabindex="-1"><a class="header-anchor" href="#_1-2-对象存活判定算法"><span>1.2 对象存活判定算法</span></a></h3><h4 id="_1-2-1-引用计数法" tabindex="-1"><a class="header-anchor" href="#_1-2-1-引用计数法"><span>1.2.1 引用计数法</span></a></h4><ul><li>原理：为每个对象添加引用计数器，当对象被引用时计数器加1，引用失效时减1，计数器为0的对象可回收</li><li>优点：实现简单，判定效率高</li><li>缺点：无法解决循环引用问题（如两个对象互相引用但都不再被其他对象引用）</li></ul><h4 id="_1-2-2-可达性分析算法" tabindex="-1"><a class="header-anchor" href="#_1-2-2-可达性分析算法"><span>1.2.2 可达性分析算法</span></a></h4><ul><li>原理：以&quot;GC Roots&quot;为起点，向下搜索所有可达的对象，不可达的对象即为可回收对象</li><li>GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI引用的对象</li><li>优点：可解决循环引用问题，是JVM实际采用的算法</li></ul><h3 id="_1-3-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_1-3-垃圾回收算法"><span>1.3 垃圾回收算法</span></a></h3><h4 id="_1-3-1-标记-清除算法-mark-sweep" tabindex="-1"><a class="header-anchor" href="#_1-3-1-标记-清除算法-mark-sweep"><span>1.3.1 标记-清除算法（Mark-Sweep）</span></a></h4><ul><li>过程：标记所有需要回收的对象，然后统一回收被标记的对象</li><li>优点：实现简单</li><li>缺点：产生内存碎片，导致大对象无法分配内存</li></ul><h4 id="_1-3-2-标记-复制算法-mark-copy" tabindex="-1"><a class="header-anchor" href="#_1-3-2-标记-复制算法-mark-copy"><span>1.3.2 标记-复制算法（Mark-Copy）</span></a></h4><ul><li>过程：将内存分为大小相等的两块，每次只使用一块，回收时将存活对象复制到另一块，然后清除使用过的内存块</li><li>优点：无内存碎片，实现简单</li><li>缺点：内存利用率低（仅50%），复制成本高</li><li>应用：新生代垃圾回收（如Serial、ParNew收集器）</li></ul><h4 id="_1-3-3-标记-整理算法-mark-compact" tabindex="-1"><a class="header-anchor" href="#_1-3-3-标记-整理算法-mark-compact"><span>1.3.3 标记-整理算法（Mark-Compact）</span></a></h4><ul><li>过程：标记存活对象，然后将存活对象向一端移动，最后清除边界以外的内存</li><li>优点：无内存碎片，内存利用率高</li><li>缺点：整理过程成本高</li><li>应用：老年代垃圾回收（如Serial Old、Parallel Old收集器）</li></ul><h4 id="_1-3-4-分代收集算法" tabindex="-1"><a class="header-anchor" href="#_1-3-4-分代收集算法"><span>1.3.4 分代收集算法</span></a></h4><ul><li>原理：根据对象存活周期将内存划分为不同区域（新生代、老年代、永久代/元空间），对不同区域采用不同回收算法</li><li>新生代：对象存活时间短，采用标记-复制算法</li><li>老年代：对象存活时间长，采用标记-清除或标记-整理算法</li><li>优点：结合了不同算法的优势，提高回收效率</li></ul><h3 id="_1-4-垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_1-4-垃圾收集器"><span>1.4 垃圾收集器</span></a></h3><p>JVM提供了多种垃圾收集器，各有特点：</p><h4 id="_1-4-1-新生代收集器" tabindex="-1"><a class="header-anchor" href="#_1-4-1-新生代收集器"><span>1.4.1 新生代收集器</span></a></h4><ul><li><strong>Serial收集器</strong>：单线程收集，简单高效，适用于Client模式</li><li><strong>ParNew收集器</strong>：Serial的多线程版本，可与CMS配合使用</li><li><strong>Parallel Scavenge收集器</strong>：关注吞吐量（运行用户代码时间/(运行用户代码时间+垃圾收集时间)），支持自适应调节策略</li></ul><h4 id="_1-4-2-老年代收集器" tabindex="-1"><a class="header-anchor" href="#_1-4-2-老年代收集器"><span>1.4.2 老年代收集器</span></a></h4><ul><li><strong>Serial Old收集器</strong>：Serial的老年代版本，单线程标记-整理算法</li><li><strong>Parallel Old收集器</strong>：Parallel Scavenge的老年代版本，多线程标记-整理算法</li><li><strong>CMS（Concurrent Mark Sweep）收集器</strong>：以获取最短回收停顿时间为目标，基于标记-清除算法，并发收集、低停顿</li><li><strong>G1（Garbage-First）收集器</strong>：面向服务端应用，兼顾吞吐量和延迟，基于Region的分代式垃圾收集器</li></ul><h2 id="代码实践" tabindex="-1"><a class="header-anchor" href="#代码实践"><span>代码实践</span></a></h2><h3 id="_2-1-查看jvm默认垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_2-1-查看jvm默认垃圾收集器"><span>2.1 查看JVM默认垃圾收集器</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GCCollectorInfo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 获取新生代垃圾收集器</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> youngCollector</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getProperty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;sun.java.command&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;JVM参数: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> youngCollector);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 获取新生代垃圾收集器</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> youngGC</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getProperty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;sun年轻代收集器&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 获取老年代垃圾收集器</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> oldGC</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getProperty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;sun老年代收集器&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;新生代收集器: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> youngGC);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;老年代收集器: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> oldGC);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-手动触发垃圾回收-不推荐在生产环境使用" tabindex="-1"><a class="header-anchor" href="#_2-2-手动触发垃圾回收-不推荐在生产环境使用"><span>2.2 手动触发垃圾回收（不推荐在生产环境使用）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GCTriggerDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i++) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> obj</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Object</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;创建对象: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> obj);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">            // 手动触发垃圾回收（仅为演示，生产环境不推荐）</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-分析gc日志" tabindex="-1"><a class="header-anchor" href="#_2-3-分析gc日志"><span>2.3 分析GC日志</span></a></h3><p>添加JVM参数打印GC日志：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>GC日志示例分析：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>2023-10-01T12:00:00.123+0800: [GC (Allocation Failure) [PSYoungGen: 524288K-&gt;65536K(786432K)] 524288K-&gt;131072K(2097152K), 0.0123450 secs] [Times: user=0.02 sys=0.01, real=0.01 secs]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>PSYoungGen：使用Parallel Scavenge收集器</li><li>524288K-&gt;65536K(786432K)：新生代GC前使用容量-&gt;GC后使用容量(新生代总容量)</li><li>524288K-&gt;131072K(2097152K)：整个堆GC前使用容量-&gt;GC后使用容量(堆总容量)</li><li>0.0123450 secs：GC耗时</li></ul><h2 id="设计思想" tabindex="-1"><a class="header-anchor" href="#设计思想"><span>设计思想</span></a></h2><h3 id="_3-1-分代回收的设计理念" tabindex="-1"><a class="header-anchor" href="#_3-1-分代回收的设计理念"><span>3.1 分代回收的设计理念</span></a></h3><p>分代回收基于对象存活周期的经验法则：</p><ul><li>大部分对象存活时间短（朝生夕死）</li><li>存活下来的对象更可能长时间存活</li></ul><p>基于这一法则，将内存划分为新生代和老年代，对不同代采用不同回收策略，提高回收效率。新生代区域小、回收频繁，采用高效的标记-复制算法；老年代区域大、回收频率低，采用标记-清除或标记-整理算法。</p><h3 id="_3-2-cms收集器的并发设计" tabindex="-1"><a class="header-anchor" href="#_3-2-cms收集器的并发设计"><span>3.2 CMS收集器的并发设计</span></a></h3><p>CMS收集器以低延迟为目标，采用并发设计：</p><ul><li><strong>初始标记</strong>：暂停所有用户线程，标记GC Roots直接关联的对象（速度快）</li><li><strong>并发标记</strong>：恢复用户线程，同时标记所有可达对象（耗时，但并发执行）</li><li><strong>重新标记</strong>：暂停所有用户线程，修正并发标记期间因用户线程操作导致标记变动的对象（比初始标记稍长，但比并发标记短）</li><li><strong>并发清除</strong>：恢复用户线程，同时清除标记的垃圾对象（耗时，但并发执行）</li></ul><p>通过减少暂停时间，CMS适合对响应时间要求高的应用。</p><h3 id="_3-3-g1收集器的region化内存布局" tabindex="-1"><a class="header-anchor" href="#_3-3-g1收集器的region化内存布局"><span>3.3 G1收集器的Region化内存布局</span></a></h3><p>G1收集器将堆内存划分为多个大小相等的独立Region，每个Region可以根据需要扮演新生代的Eden区、Survivor区或老年代空间。这种设计允许G1跟踪各个Region的垃圾堆积价值，优先回收价值最高的Region（Garbage-First），从而在有限时间内获得最高的回收效率。</p><h2 id="避坑指南" tabindex="-1"><a class="header-anchor" href="#避坑指南"><span>避坑指南</span></a></h2><h3 id="_4-1-不要过度依赖system-gc" tabindex="-1"><a class="header-anchor" href="#_4-1-不要过度依赖system-gc"><span>4.1 不要过度依赖System.gc()</span></a></h3><ul><li>System.gc()只是建议JVM进行垃圾回收，JVM可以忽略该请求</li><li>频繁调用会影响性能，增加GC overhead</li><li>生产环境应禁用显式GC：-XX:+DisableExplicitGC</li></ul><h3 id="_4-2-避免内存泄漏" tabindex="-1"><a class="header-anchor" href="#_4-2-避免内存泄漏"><span>4.2 避免内存泄漏</span></a></h3><ul><li><strong>静态集合类泄漏</strong>：静态集合持有对象引用，导致对象无法回收<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StaticCollectionLeak</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> List</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> list </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> obj</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj); </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// obj永远不会被回收</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>监听器和回调泄漏</strong>：注册监听器但未注销</li><li><strong>资源未关闭泄漏</strong>：数据库连接、IO流等资源未关闭</li></ul><h3 id="_4-3-合理设置堆内存大小" tabindex="-1"><a class="header-anchor" href="#_4-3-合理设置堆内存大小"><span>4.3 合理设置堆内存大小</span></a></h3><ul><li>堆内存过小：频繁GC，甚至OOM</li><li>堆内存过大：单次GC时间过长，浪费系统资源</li><li>建议：根据应用实际需求和服务器配置设置，新生代和老年代比例一般为1:2</li></ul><h3 id="_4-4-cms收集器的常见问题" tabindex="-1"><a class="header-anchor" href="#_4-4-cms收集器的常见问题"><span>4.4 CMS收集器的常见问题</span></a></h3><ul><li><strong>内存碎片</strong>：基于标记-清除算法，长期运行会产生内存碎片 解决：开启-XX:+UseCMSCompactAtFullCollection，在Full GC后进行内存整理</li><li><strong>Concurrent Mode Failure</strong>：并发清除阶段用户线程分配内存速度超过GC回收速度 解决：增大老年代空间，或使用G1收集器替代</li></ul><h2 id="深度思考题" tabindex="-1"><a class="header-anchor" href="#深度思考题"><span>深度思考题</span></a></h2><ol><li>G1收集器与CMS收集器相比有哪些优势？适用于什么场景？</li><li>什么是内存分配担保机制？它在垃圾回收中起到什么作用？</li><li>如何排查和解决JVM内存泄漏问题？</li></ol><p>思考题回答：</p><ol><li><p>G1收集器的优势：</p><ul><li>基于Region的内存布局，可预测的停顿时间</li><li>兼顾吞吐量和延迟</li><li>不会产生大量内存碎片</li><li>可动态调整新生代和老年代大小 适用场景：堆内存较大（一般大于4GB）、对停顿时间有要求的应用</li></ul></li><li><p>内存分配担保机制是指当新生代无法为新对象分配内存时，JVM会检查老年代最大可用连续空间是否大于新生代所有对象总大小。如果大于，则进行Minor GC；如果小于，则查看HandlePromotionFailure参数是否允许担保失败。如果允许，则尝试Minor GC；如果不允许，则进行Full GC。内存分配担保机制是为了减少Full GC的频率。</p></li><li><p>排查和解决JVM内存泄漏问题的步骤：</p><ul><li>监控JVM内存使用情况，观察是否有内存持续增长</li><li>发生OOM时，通过-XX:+HeapDumpOnOutOfMemoryError参数获取堆转储文件</li><li>使用MAT、JProfiler等工具分析堆转储文件，找出泄漏对象</li><li>分析泄漏对象的引用链，确定泄漏原因</li><li>修改代码，解除不必要的对象引用</li></ul></li></ol>`,61),t=[e];function h(k,p){return a(),s("div",null,t)}const g=i(n,[["render",h],["__file","5.5 JVM垃圾回收机制.html.vue"]]),c=JSON.parse('{"path":"/java/6%E3%80%81JVM%E5%8E%9F%E7%90%86/5.5%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html","title":"5.5 JVM垃圾回收机制","lang":"zh-CN","frontmatter":{"description":"5.5 JVM垃圾回收机制 核心理论 1.1 垃圾回收基本概念 垃圾回收（Garbage Collection, GC）是JVM自动管理内存的机制，主要负责： 识别内存中不再使用的对象（垃圾） 回收这些对象占用的内存空间 整理内存碎片（可选） 垃圾回收的目标是实现内存自动管理，减少内存泄漏和内存溢出问题，提高开发效率。 1.2 对象存活判定算法 1.2...","head":[["meta",{"property":"og:url","content":"http://blog.lindaifeng.vip/java/6%E3%80%81JVM%E5%8E%9F%E7%90%86/5.5%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"文档演示"}],["meta",{"property":"og:title","content":"5.5 JVM垃圾回收机制"}],["meta",{"property":"og:description","content":"5.5 JVM垃圾回收机制 核心理论 1.1 垃圾回收基本概念 垃圾回收（Garbage Collection, GC）是JVM自动管理内存的机制，主要负责： 识别内存中不再使用的对象（垃圾） 回收这些对象占用的内存空间 整理内存碎片（可选） 垃圾回收的目标是实现内存自动管理，减少内存泄漏和内存溢出问题，提高开发效率。 1.2 对象存活判定算法 1.2..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-04T07:10:04.000Z"}],["meta",{"property":"article:author","content":"清峰"}],["meta",{"property":"article:modified_time","content":"2025-07-04T07:10:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.5 JVM垃圾回收机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-04T07:10:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"清峰\\",\\"url\\":\\"http://blog.lindaifeng.vip/\\"}]}"]]},"headers":[{"level":2,"title":"核心理论","slug":"核心理论","link":"#核心理论","children":[{"level":3,"title":"1.1 垃圾回收基本概念","slug":"_1-1-垃圾回收基本概念","link":"#_1-1-垃圾回收基本概念","children":[]},{"level":3,"title":"1.2 对象存活判定算法","slug":"_1-2-对象存活判定算法","link":"#_1-2-对象存活判定算法","children":[]},{"level":3,"title":"1.3 垃圾回收算法","slug":"_1-3-垃圾回收算法","link":"#_1-3-垃圾回收算法","children":[]},{"level":3,"title":"1.4 垃圾收集器","slug":"_1-4-垃圾收集器","link":"#_1-4-垃圾收集器","children":[]}]},{"level":2,"title":"代码实践","slug":"代码实践","link":"#代码实践","children":[{"level":3,"title":"2.1 查看JVM默认垃圾收集器","slug":"_2-1-查看jvm默认垃圾收集器","link":"#_2-1-查看jvm默认垃圾收集器","children":[]},{"level":3,"title":"2.2 手动触发垃圾回收（不推荐在生产环境使用）","slug":"_2-2-手动触发垃圾回收-不推荐在生产环境使用","link":"#_2-2-手动触发垃圾回收-不推荐在生产环境使用","children":[]},{"level":3,"title":"2.3 分析GC日志","slug":"_2-3-分析gc日志","link":"#_2-3-分析gc日志","children":[]}]},{"level":2,"title":"设计思想","slug":"设计思想","link":"#设计思想","children":[{"level":3,"title":"3.1 分代回收的设计理念","slug":"_3-1-分代回收的设计理念","link":"#_3-1-分代回收的设计理念","children":[]},{"level":3,"title":"3.2 CMS收集器的并发设计","slug":"_3-2-cms收集器的并发设计","link":"#_3-2-cms收集器的并发设计","children":[]},{"level":3,"title":"3.3 G1收集器的Region化内存布局","slug":"_3-3-g1收集器的region化内存布局","link":"#_3-3-g1收集器的region化内存布局","children":[]}]},{"level":2,"title":"避坑指南","slug":"避坑指南","link":"#避坑指南","children":[{"level":3,"title":"4.1 不要过度依赖System.gc()","slug":"_4-1-不要过度依赖system-gc","link":"#_4-1-不要过度依赖system-gc","children":[]},{"level":3,"title":"4.2 避免内存泄漏","slug":"_4-2-避免内存泄漏","link":"#_4-2-避免内存泄漏","children":[]},{"level":3,"title":"4.3 合理设置堆内存大小","slug":"_4-3-合理设置堆内存大小","link":"#_4-3-合理设置堆内存大小","children":[]},{"level":3,"title":"4.4 CMS收集器的常见问题","slug":"_4-4-cms收集器的常见问题","link":"#_4-4-cms收集器的常见问题","children":[]}]},{"level":2,"title":"深度思考题","slug":"深度思考题","link":"#深度思考题","children":[]}],"git":{"createdTime":1751613004000,"updatedTime":1751613004000,"contributors":[{"name":"ldf","email":"1305366530@qq.com","commits":1}]},"readingTime":{"minutes":7.7,"words":2311},"filePathRelative":"java/6、JVM原理/5.5 JVM垃圾回收机制.md","localizedDate":"2025年7月4日","autoDesc":true,"excerpt":"\\n<h2>核心理论</h2>\\n<h3>1.1 垃圾回收基本概念</h3>\\n<p>垃圾回收（Garbage Collection, GC）是JVM自动管理内存的机制，主要负责：</p>\\n<ul>\\n<li>识别内存中不再使用的对象（垃圾）</li>\\n<li>回收这些对象占用的内存空间</li>\\n<li>整理内存碎片（可选）</li>\\n</ul>\\n<p>垃圾回收的目标是实现内存自动管理，减少内存泄漏和内存溢出问题，提高开发效率。</p>\\n<h3>1.2 对象存活判定算法</h3>\\n<h4>1.2.1 引用计数法</h4>\\n<ul>\\n<li>原理：为每个对象添加引用计数器，当对象被引用时计数器加1，引用失效时减1，计数器为0的对象可回收</li>\\n<li>优点：实现简单，判定效率高</li>\\n<li>缺点：无法解决循环引用问题（如两个对象互相引用但都不再被其他对象引用）</li>\\n</ul>"}');export{g as comp,c as data};
