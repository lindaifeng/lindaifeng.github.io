import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as n,f as t}from"./app-X4Oeetgs.js";const e={},p=t(`<h2 id="springboot底层原理实现" tabindex="-1"><a class="header-anchor" href="#springboot底层原理实现"><span>SpringBoot底层原理实现</span></a></h2><p><strong>思考：bean是如何被创建的？</strong></p><h2 id="一、自动装配原理一bean的创建" tabindex="-1"><a class="header-anchor" href="#一、自动装配原理一bean的创建"><span>一、自动装配原理一bean的创建：</span></a></h2><p><strong>condition</strong>：条件判断</p><p>用于bean的创建中，当满足条件时则返回ture，不满足则返回false，根据返回值判断是否要执行创建bean的方法。true创建bean</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Conditional</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">OnBeanCondition</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">下面的注解都被</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Conditional修饰执行</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()中不同类的条件判断方法</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ConditionalOnClass</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">		//存在类则为满足条件创建bean</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ConditionalOnMissingBean</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">	//不存在则满足条件创建bean</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>思考：SpringBoot是如何知道要创建哪个bean的？</strong>(难道所有的bean都创建，IOC容器能装下？)</p><p>1、思路：导入依赖坐标后会加载jar包导入相应的字节码文件，编译时也会加载相应的字节码文件，可以根据判断加载对应的字节码创建对应的bean。</p><p>而springboot给我们提供的一个接口condition就用来判断bean的创建条件。该接口通过注解@Conditional(条件类)配合使用。 <strong>具体实现</strong>：</p><p>案例：需要导入redis依赖才将user对象注入bean中！</p><p>1、springboot项目启动时会进行初始化，@Configuration加载@bean，如果被@ConditionalOnClass标记则会先进行判断，是否满足条件(有这个类或者是他的字节码文件)</p><p>如图：如果有加载该全路径类名(有类)则满足条件。</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114211907733.png" alt="image-20210114211907733" tabindex="0" loading="lazy"><figcaption>image-20210114211907733</figcaption></figure><p>2、@ConditionalOnClass注解被@Conditional标识用于存储值给MyIfBean类(自定义条件类)使用</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114212748351.png" alt="image-20210114212748351" tabindex="0" loading="lazy"><figcaption>image-20210114212748351</figcaption></figure><p>3、@Conditional注解用于初始化器实现类对标记的值进行判断是否满足条件</p><blockquote><p>1、先获取@ConditionalOnClass注解</p><p>2、再获取被@ConditionalOnClass注解标识的value值(存有字节码文件.class)</p><p>3、遍历value数组加载字节码对象，加载成功则返回true顺利创建bean，其中有加载失败则表明没有该字节码文件，返回falsebean1创建失败报错</p></blockquote><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114213006730.png" alt="image-20210114213006730" tabindex="0" loading="lazy"><figcaption>image-20210114213006730</figcaption></figure><p>4、满足条件则后续进行创建bean，不满足则报错无法加载bean</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114211335030.png" alt="image-20210114211335030" tabindex="0" loading="lazy"><figcaption>image-20210114211335030</figcaption></figure><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114221244630.png" alt="image-20210114221244630" tabindex="0" loading="lazy"><figcaption>image-20210114221244630</figcaption></figure><h2 id="二、自动装配原理二内置服务器的切换" tabindex="-1"><a class="header-anchor" href="#二、自动装配原理二内置服务器的切换"><span>二、自动装配原理二内置服务器的切换</span></a></h2><p>springboot内置了四种服务器当导入不同的依赖时，会自动装配不同的服务器（当导入web依赖时会加载tomcat字节码文件，自动装配tomcat服务器注入到bean中）</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114223141212.png" alt="image-20210114223141212" tabindex="0" loading="lazy"><figcaption>image-20210114223141212</figcaption></figure><p><strong>切换服务器只需要排除原有的，添加新的依赖即可</strong></p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114223646834.png" alt="image-20210114223646834" tabindex="0" loading="lazy"><figcaption>image-20210114223646834</figcaption></figure><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114224028196.png" alt="image-20210114224028196" tabindex="0" loading="lazy"><figcaption>image-20210114224028196</figcaption></figure><h2 id="三、自动装配原理三enable注解原理" tabindex="-1"><a class="header-anchor" href="#三、自动装配原理三enable注解原理"><span>三、自动装配原理三Enable注解原理</span></a></h2><p><strong>思考：一个springboot项目能够直接加载jar包中的bean吗？</strong></p><p>不能！</p><p>分析启动类上的注解@SpringBootApplication</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@SpringBootConfiguration //表明是一个配置类</span></span>
<span class="line"><span>@EnableAutoConfiguration //导入其他类，实现其中类的功能</span></span>
<span class="line"><span>@ComponentScan()	//包扫描（扫描当前包和其子包）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、主要是@ComponentScan这个注解只会扫描当前包和其子包，并不会扫描其他包，所以不会加载其他类中的bean。</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115163920227.png" alt="image-20210115163920227" tabindex="0" loading="lazy"><figcaption>image-20210115163920227</figcaption></figure><p><strong>思考：如何加载其他类中的bean</strong></p><p>1、ComponentScan(其他包路径)</p><p>2、@Import(其他类)</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115163043778.png" alt="image-20210115163043778" tabindex="0" loading="lazy"><figcaption>image-20210115163043778</figcaption></figure><p>SpringBoot提供了@Eable*注解用于动态加载bean，原理就是在在注解上加入了@Import注解并导入了一些配置类，使得该注解可以动态加载自己特有的bean，实现某功能。</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115165051510.png" alt="image-20210115165051510" tabindex="0" loading="lazy"><figcaption>image-20210115165051510</figcaption></figure><h2 id="四、自动装配原理四-import原理" tabindex="-1"><a class="header-anchor" href="#四、自动装配原理四-import原理"><span>四、自动装配原理四@Import原理</span></a></h2><p>@Import()：导入的类会被Spring加载到IOC容器中</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115170016721.png" alt="image-20210115170016721" tabindex="0" loading="lazy"><figcaption>image-20210115170016721</figcaption></figure><p>1、导入一个bean类对象直接加载到中IOC容器中</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115180721908.png" alt="image-20210115180721908" tabindex="0" loading="lazy"><figcaption>image-20210115180721908</figcaption></figure><p>2、导入一个配置类，加载配置类文件加载bean</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115180701704.png" alt="image-20210115180701704" tabindex="0" loading="lazy"><figcaption>image-20210115180701704</figcaption></figure><p>3、导入一个ImportSelector自定义实现类，根据全路径类名加载多个bean到IOC容器中，通过将全路径类名写入配置文件中，可实现动态加载bean。（springboot初始化配置就是用到该接口实现加载多个配置文件，实现批量动态加载bean）</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115181157737.png" alt="image-20210115181157737" tabindex="0" loading="lazy"><figcaption>image-20210115181157737</figcaption></figure><p>4、导入一个ImportBeanDefinitionRegistrar自定义实现类，加载指定类注册到IOC容器中。</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115181038711.png" alt="image-20210115181038711" tabindex="0" loading="lazy"><figcaption>image-20210115181038711</figcaption></figure><h2 id="五、自动装配原理五-enableautoconfiguration注解" tabindex="-1"><a class="header-anchor" href="#五、自动装配原理五-enableautoconfiguration注解"><span>五、自动装配原理五@EnableAutoConfiguration注解</span></a></h2><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115183651159.png" alt="image-20210115183651159" tabindex="0" loading="lazy"><figcaption>image-20210115183651159</figcaption></figure><p>1、在启动类上@SpringBootApplication中有标识@EnableAutoConfiguration注解表示自动配置。</p><p>2、当启动项目时，会加载这个注解内部中的@Import(AutoConfigurationImportSelector.class)装载的类。</p><p>3、该类AutoConfigurationImportSelector.class主要是会去加载配置文件META-INF/spring.factories，该配置文件中定义了大量的配置类</p><p>4、但不会所有配置都会加载而是有条件的加载，满足@Conditional()的配置文件会被加载</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115184613356.png" alt="image-20210115184613356" tabindex="0" loading="lazy"><figcaption>image-20210115184613356</figcaption></figure><h1 id="总结-springboot自动装配原理" tabindex="-1"><a class="header-anchor" href="#总结-springboot自动装配原理"><span>总结：SpringBoot自动装配原理</span></a></h1><p>1、启动springboot启动类时，项目会执行main方法构建项目并加载IOC容器。</p><p>2、启动类标识了@SpringBootApplication注解，该注解被</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@SpringBootConfiguration //标识这个一个配置类</span></span>
<span class="line"><span>@EnableAutoConfiguration //开启自动配置</span></span>
<span class="line"><span>@ComponentScan //扫描包以及子包</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三个注解所修饰，加载这个配置类，扫描包以及子包，并自动加载配置类将所需bean注入到IOC容器中</p><p>3、其中@EnableAutoConfiguration又被@Import(AutoConfigurationImportSelector.class)修饰，他会加载其配置类到IOC容器中，主要执行的方法是加载扫描到的包中查找一个/WEAT-INF/spring.factories文件，该文件配置了很多类的全路径类名，加载后进行bean的创建</p><p>4、并·不是所有的bean都会创建，满足各自配置类中符合@Conditional注解的条件则创建，不满足则不会创建。</p><figure><img src="http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210116194252647.png" alt="image-20210116194252647" tabindex="0" loading="lazy"><figcaption>image-20210116194252647</figcaption></figure><blockquote><p>核心简化：SpringBoot自动装配原理</p><p>1、启动引导类上标识了@SpringBootApplication该引导类中有一个核心注解@EnableAutoConfiguration (开启自动配置)</p><p>2、@EnableAutoConfiguration (开启自动配置)注解被@Import(AutoConfigurationImportSelector.class)标识，会加载其配置类，该类会加载/MEAT-INF/spring.profactories文件。</p><p>3、该配置文件配置了所有springboot官方整合的其他依赖的全路径类名，通过加载各配置类生成bean注入IOC容器中</p><p>4、并不会将所有配置文件中的bean都会加载，再各配置类中加入了@Conditional注解进行条件判断，满足条件(大多是加载有无该对象字节码文件)才加载该bean。这样在导入相关依赖后才有对应字节码文件，在会满足相应@Conditional条件加载相应的bean</p></blockquote>`,67),g=[p];function s(o,l){return n(),a("div",null,g)}const c=i(e,[["render",s],["__file","SpringBoot自动装配原理.html.vue"]]),d=JSON.parse('{"path":"/frame/springboot/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86.html","title":"SpringBoot底层原理实现","lang":"zh-CN","frontmatter":{"title":"SpringBoot底层原理实现","order":1,"description":"SpringBoot底层原理实现 思考：bean是如何被创建的？ 一、自动装配原理一bean的创建： condition：条件判断 用于bean的创建中，当满足条件时则返回ture，不满足则返回false，根据返回值判断是否要执行创建bean的方法。true创建bean 思考：SpringBoot是如何知道要创建哪个bean的？(难道所有的bean都创...","head":[["meta",{"property":"og:url","content":"http://blog.lindaifeng.vip/frame/springboot/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"文档演示"}],["meta",{"property":"og:title","content":"SpringBoot底层原理实现"}],["meta",{"property":"og:description","content":"SpringBoot底层原理实现 思考：bean是如何被创建的？ 一、自动装配原理一bean的创建： condition：条件判断 用于bean的创建中，当满足条件时则返回ture，不满足则返回false，根据返回值判断是否要执行创建bean的方法。true创建bean 思考：SpringBoot是如何知道要创建哪个bean的？(难道所有的bean都创..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114211907733.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-22T02:23:17.000Z"}],["meta",{"property":"article:author","content":"清峰"}],["meta",{"property":"article:modified_time","content":"2024-10-22T02:23:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SpringBoot底层原理实现\\",\\"image\\":[\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114211907733.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114212748351.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114213006730.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114211335030.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114221244630.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114223141212.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114223646834.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210114224028196.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115163920227.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115163043778.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115165051510.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115170016721.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115180721908.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115180701704.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115181157737.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115181038711.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115183651159.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210115184613356.png\\",\\"http://img.lindaifeng.vip/typora-picgo-tuchaung/image-20210116194252647.png\\"],\\"dateModified\\":\\"2024-10-22T02:23:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"清峰\\",\\"url\\":\\"http://blog.lindaifeng.vip/\\"}]}"]]},"headers":[{"level":2,"title":"SpringBoot底层原理实现","slug":"springboot底层原理实现","link":"#springboot底层原理实现","children":[]},{"level":2,"title":"一、自动装配原理一bean的创建：","slug":"一、自动装配原理一bean的创建","link":"#一、自动装配原理一bean的创建","children":[]},{"level":2,"title":"二、自动装配原理二内置服务器的切换","slug":"二、自动装配原理二内置服务器的切换","link":"#二、自动装配原理二内置服务器的切换","children":[]},{"level":2,"title":"三、自动装配原理三Enable注解原理","slug":"三、自动装配原理三enable注解原理","link":"#三、自动装配原理三enable注解原理","children":[]},{"level":2,"title":"四、自动装配原理四@Import原理","slug":"四、自动装配原理四-import原理","link":"#四、自动装配原理四-import原理","children":[]},{"level":2,"title":"五、自动装配原理五@EnableAutoConfiguration注解","slug":"五、自动装配原理五-enableautoconfiguration注解","link":"#五、自动装配原理五-enableautoconfiguration注解","children":[]}],"git":{"createdTime":1729563797000,"updatedTime":1729563797000,"contributors":[{"name":"ldf","email":"1305366530@qq.com","commits":1}]},"readingTime":{"minutes":5.61,"words":1683},"filePathRelative":"frame/springboot/SpringBoot自动装配原理.md","localizedDate":"2024年10月22日","autoDesc":true,"excerpt":"<h2>SpringBoot底层原理实现</h2>\\n<p><strong>思考：bean是如何被创建的？</strong></p>\\n<h2>一、自动装配原理一bean的创建：</h2>\\n<p><strong>condition</strong>：条件判断</p>\\n<p>用于bean的创建中，当满足条件时则返回ture，不满足则返回false，根据返回值判断是否要执行创建bean的方法。true创建bean</p>\\n<div class=\\"language-java line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"java\\" data-title=\\"java\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">@</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#E5C07B\\">Conditional</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\">(</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\">OnBeanCondition</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">.</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\">class</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\">)</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\">下面的注解都被</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">@</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#E5C07B\\">Conditional修饰执行</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\">()中不同类的条件判断方法</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">@</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#E5C07B\\">ConditionalOnClass</span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\">\\t\\t//存在类则为满足条件创建bean</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">@</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#E5C07B\\">ConditionalOnMissingBean</span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\">\\t//不存在则满足条件创建bean</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{c as comp,d as data};
